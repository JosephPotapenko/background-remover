<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Background Remover</title>
  <style>
    body { font-family: sans-serif; padding: 2rem; background: #f9f9f9; text-align: center; }
    .image-container { border: 1px solid #ccc; margin: 1rem auto; display: inline-block; position: relative; }
    canvas { cursor: crosshair; display: block; margin: 0 auto; }
    .controls { margin: 0.5rem 0; }
    label { margin-right: 1rem; }
    button { margin: 0.5rem; }
    .select-checkbox { position: absolute; top: 5px; left: 5px; }
    #bottom-controls { margin-top: 2rem; }
    details { margin: 1rem auto; text-align: left; max-width: 800px; }
    .controls button.smooth-btn {
      background-color: #ffc107;
      color: #333;
      border: none;
      border-radius: 4px;
    }
    .controls button.spec-btn {
      background-color: #343a40;
      color: #fff;
      border: none;
      border-radius: 4px;
    }
    .controls button.undo-btn, .controls button.redo-btn {
      background-color: #6c757d;
      color: #fff;
      border: none;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h2>Advanced Background Remover</h2>
  <details>
    <summary style="max-width: 640px; margin: 0 auto 1em auto; text-align: center;"><strong>Instructions</strong></summary>
    <p style="max-width: 640px; margin: 0 auto 1em auto;"></p>
      Upload one or more images using the file input below. You can edit each image manually using the brush tools:
      <br><span style="margin-left:2em;"><strong>Erase</strong></span> to remove,
      <br><span style="margin-left:2em;"><strong>Restore</strong></span> to paint back original content, or use
      <br><span style="margin-left:2em;"><strong>Magic Fill</strong></span> to remove areas with similar colors by clicking. Adjust brush size and tolerance as needed.
      <br><br>Optionally, use the:
      <br><span style="margin-left:2em;"><strong>Auto Process</strong></span> button under each image to automatically remove background based on edge detection. 
      <br><br>All actions including auto-processing are undoable using the:
      <br><span style="margin-left:2em;"><strong>Undo</strong></span> button. Select images and click
      <br><span style="margin-left:2em;"><strong>Download Selected</strong></span> to save your edits.
    </p>
    <br>
  </details>

  <input type="file" id="fileInput" accept="image/*" multiple><br>
  <label>Brush Size: <input type="range" id="brushSize" min="5" max="100" value="30"></label>
  <label><input type="radio" name="mode" value="erase" checked> Erase</label>
  <label><input type="radio" name="mode" value="restore"> Restore</label>
  <label><input type="radio" name="mode" value="bucket"> Magic Fill</label>
  <label>Tolerance: <input type="range" id="tolerance" min="0" max="100" value="30"></label>

  <div id="imagesArea"></div>

  <div id="bottom-controls">
    <button id="selectAllBtn">Select All</button>
    <button id="deselectAllBtn">Deselect All</button>
    <button id="downloadSelectedBtn">Download Selected</button>
  </div>

  <script>
    const brushSizeInput = document.getElementById("brushSize");
    const toleranceInput = document.getElementById("tolerance");
    const modeRadios = document.querySelectorAll('input[name="mode"]');
    const imagesArea = document.getElementById("imagesArea");
    const downloadSelectedBtn = document.getElementById("downloadSelectedBtn");
    const selectAllBtn = document.getElementById("selectAllBtn");
    const deselectAllBtn = document.getElementById("deselectAllBtn");

    let brushSize = parseInt(brushSizeInput.value);
    let tolerance = parseInt(toleranceInput.value);
    let mode = "erase";

    brushSizeInput.oninput = e => brushSize = parseInt(e.target.value);
    toleranceInput.oninput = e => tolerance = parseInt(e.target.value);
    modeRadios.forEach(r => r.onchange = () => mode = document.querySelector('input[name="mode"]:checked').value);

    function colorDistance(c1, c2) {
      return Math.sqrt((c1[0]-c2[0])**2 + (c1[1]-c2[1])**2 + (c1[2]-c2[2])**2);
    }

    function getPixel(data, x, y, w) {
      const i = (y * w + x) * 4;
      return [data[i], data[i+1], data[i+2], data[i+3]];
    }

    function setAlpha(data, x, y, w, alpha) {
      const i = (y * w + x) * 4;
      data[i+3] = alpha;
    }

    function floodFill(x, y, data, w, h, base, tol) {
      const stack = [[x, y]];
      const visited = new Set();
      while (stack.length) {
        const [cx, cy] = stack.pop();
        const key = `${cx},${cy}`;
        if (visited.has(key)) continue;
        visited.add(key);
        const px = getPixel(data, cx, cy, w);
        if (px[3] === 0 || colorDistance(px, base) > tol) continue;
        setAlpha(data, cx, cy, w, 0);
        if (cx > 0) stack.push([cx-1, cy]);
        if (cx < w-1) stack.push([cx+1, cy]);
        if (cy > 0) stack.push([cx, cy-1]);
        if (cy < h-1) stack.push([cx, cy+1]);
      }
    }

    function getEdgeColor(data, w, h) {
      const sample = [];
      for (let x = 0; x < w; x++) sample.push([x,0],[x,h-1]);
      for (let y = 0; y < h; y++) sample.push([0,y],[w-1,y]);
      return sample.reduce((acc, [x,y]) => {
        const i = (y*w + x)*4;
        acc[0] += data[i]; acc[1] += data[i+1]; acc[2] += data[i+2];
        return acc;
      }, [0,0,0]).map(v => v/sample.length);
    }

    class ImageEditor {
      constructor(file) {
        this.file = file;
        this.canvas = document.createElement("canvas");
        this.ctx = this.canvas.getContext("2d");
        this.container = document.createElement("div");
        this.container.className = "image-container";

        this.selectCheckbox = document.createElement("input");
        this.selectCheckbox.type = "checkbox";
        this.selectCheckbox.className = "select-checkbox";
        this.selectCheckbox.checked = true;

        this.undoBtn = document.createElement("button");
        this.undoBtn.textContent = "Undo";

        this.autoBtn = document.createElement("button");
        this.autoBtn.textContent = "Auto Process";

        this.downloadBtn = document.createElement("button");
        this.downloadBtn.textContent = "Download";
        this.continueBtn = document.createElement("button");
        this.continueBtn.textContent = "Continue Editing";
        // Smoothing slider and button
        this.smoothSlider = document.createElement("input");
        this.smoothSlider.type = "range";
        this.smoothSlider.min = 0;
        this.smoothSlider.max = 100;
        this.smoothSlider.value = 0;
        this.smoothSlider.style.width = "80px";
        this.smoothBtn = document.createElement("button");
        this.smoothBtn.textContent = "Smooth Edges";
        this.smoothBtn.className = "smooth-btn";
        // Remove specs button
        this.specBtn = document.createElement("button");
        this.specBtn.textContent = "Remove Specs";
        this.specBtn.className = "spec-btn";
        // Undo/Redo buttons
        this.undoBtn2 = document.createElement("button");
        this.undoBtn2.textContent = "Undo";
        this.undoBtn2.className = "undo-btn";
        this.redoBtn = document.createElement("button");
        this.redoBtn.textContent = "Redo";
        this.redoBtn.className = "redo-btn";
        this.controls = document.createElement("div");
        this.controls.className = "controls";
        this.controls.appendChild(this.undoBtn);
        this.controls.appendChild(this.autoBtn);
        this.controls.appendChild(this.downloadBtn);
        this.controls.appendChild(this.continueBtn);
        this.controls.appendChild(this.smoothSlider);
        this.controls.appendChild(this.smoothBtn);
        this.controls.appendChild(this.specBtn);
        this.controls.appendChild(this.undoBtn2);
        this.controls.appendChild(this.redoBtn);

        this.container.appendChild(this.selectCheckbox);
        this.container.appendChild(this.canvas);
        this.container.appendChild(this.controls);
        imagesArea.appendChild(this.container);

        this.img = new Image();
        this.img.onload = () => this.init();
        this.img.src = URL.createObjectURL(file);

        this.undoStack = [];
        this.redoStack = [];

        this.canvas.addEventListener("mousedown", e => { 
          this.drawing = true; 
          this.strokeStarted = false;
          this.draw(e); 
        });
        this.canvas.addEventListener("mousemove", e => this.drawing && this.draw(e));
        this.canvas.addEventListener("mouseup", () => this.drawing = false);
        this.canvas.addEventListener("mouseleave", () => this.drawing = false);
        this.undoBtn.onclick = () => this.undo();
        this.autoBtn.onclick = () => this.autoProcess();
        this.downloadBtn.onclick = () => this.download();
        this.continueBtn.onclick = () => this.sendToSecondStage();
        this.smoothBtn.onclick = () => this.smoothEdges();
        this.specBtn.onclick = () => this.removeSpecs();
        this.undoBtn2.onclick = () => this.undo();
        this.redoBtn.onclick = () => this.redo();
      }

      init() {
        this.canvas.width = this.img.width;
        this.canvas.height = this.img.height;
        this.ctx.drawImage(this.img, 0, 0);
        this.original = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      }

      autoProcess() {
        this.save();
        let id = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        let d = id.data, w = this.canvas.width, h = this.canvas.height;
        let bg = getEdgeColor(d, w, h);
        for (let i = 0; i < d.length; i += 4) {
          let [r,g,b] = [d[i], d[i+1], d[i+2]];
          let dist = colorDistance([r,g,b], bg);
          if (dist < 50) d[i+3] = 0;
        }
        this.ctx.putImageData(id, 0, 0);
      }

      draw(e) {
        const r = this.canvas.getBoundingClientRect();
        const x = Math.floor(e.clientX - r.left);
        const y = Math.floor(e.clientY - r.top);
        
        // Only save once at the start of a stroke for erase/restore modes
        if ((mode === "erase" || mode === "restore") && !this.strokeStarted) {
          this.save();
          this.strokeStarted = true;
        }
        
        if (mode === "erase") {
          this.ctx.save();
          this.ctx.beginPath();
          this.ctx.arc(x, y, brushSize/2, 0, 2*Math.PI);
          this.ctx.clip();
          this.ctx.clearRect(x-brushSize/2, y-brushSize/2, brushSize, brushSize);
          this.ctx.restore();
        } else if (mode === "restore") {
          for (let dx = -brushSize/2; dx < brushSize/2; dx++) {
            for (let dy = -brushSize/2; dy < brushSize/2; dy++) {
              const sx = x + dx, sy = y + dy;
              if (sx < 0 || sy < 0 || sx >= this.canvas.width || sy >= this.canvas.height) continue;
              const idx = (sy * this.canvas.width + sx) * 4;
              const r = this.original.data[idx];
              const g = this.original.data[idx + 1];
              const b = this.original.data[idx + 2];
              const a = this.original.data[idx + 3];
              this.ctx.fillStyle = `rgba(${r},${g},${b},${a/255})`;
              this.ctx.fillRect(sx, sy, 1, 1);
            }
          }
        } else if (mode === "bucket") {
          // Magic Fill still saves immediately since it's a single click operation
          this.save();
          let id = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
          let px = getPixel(id.data, x, y, this.canvas.width);
          floodFill(x, y, id.data, this.canvas.width, this.canvas.height, px, tolerance);
          this.ctx.putImageData(id, 0, 0);
        }
      }

      save() {
        this.undoStack.push(this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height));
        if (this.undoStack.length > 50) this.undoStack.shift();
        // Clear redo stack on new action
        this.redoStack = [];
      }

      undo() {
        if (!this.undoStack.length) return;
        const last = this.undoStack.pop();
        this.redoStack.push(this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height));
        this.ctx.putImageData(last, 0, 0);
      }

      redo() {
        if (!this.redoStack.length) return;
        this.save(); // Save current before redo
        const redoImg = this.redoStack.pop();
        this.ctx.putImageData(redoImg, 0, 0);
      }

      smoothEdges() {
        this.save();
        // Smoothing algorithm: erode then dilate based on slider value
        const level = parseInt(this.smoothSlider.value);
        if (level === 0) return; // No smoothing
        let id = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        let data = id.data, w = this.canvas.width, h = this.canvas.height;
        // Erode: shrink alpha edges
        for (let n = 0; n < Math.ceil(level/20); n++) {
          let newAlpha = new Uint8ClampedArray(data.length);
          for (let y = 1; y < h-1; y++) {
            for (let x = 1; x < w-1; x++) {
              const i = (y*w + x)*4 + 3;
              if (data[i] === 0) continue;
              let count = 0;
              for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                  if (dx === 0 && dy === 0) continue;
                  if (data[((y+dy)*w + (x+dx))*4 + 3] === 0) count++;
                }
              }
              newAlpha[i] = count > 2 ? 0 : data[i];
            }
          }
          for (let i = 3; i < data.length; i += 4) if (newAlpha[i]) data[i] = newAlpha[i];
        }
        // Dilate: grow alpha edges
        for (let n = 0; n < Math.ceil(level/20); n++) {
          let newAlpha = new Uint8ClampedArray(data.length);
          for (let y = 1; y < h-1; y++) {
            for (let x = 1; x < w-1; x++) {
              const i = (y*w + x)*4 + 3;
              if (data[i] !== 0) continue;
              let count = 0;
              for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                  if (dx === 0 && dy === 0) continue;
                  if (data[((y+dy)*w + (x+dx))*4 + 3] > 0) count++;
                }
              }
              newAlpha[i] = count > 2 ? 255 : data[i];
            }
          }
          for (let i = 3; i < data.length; i += 4) if (newAlpha[i]) data[i] = newAlpha[i];
        }
        this.ctx.putImageData(id, 0, 0);
      }

      removeSpecs() {
        this.save();
        // Remove small isolated specs/blotches that are not connected to main image areas
        let id = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        let data = id.data, w = this.canvas.width, h = this.canvas.height;
        let visited = new Uint8Array(w*h);
        let mainAreas = new Set(); // Store pixels that are part of main image areas
        
        function getIdx(x, y) { return y*w + x; }
        
        // First pass: identify all connected components and mark large ones as main areas
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const i = getIdx(x, y);
            if (visited[i]) continue;
            const alpha = data[i*4+3];
            if (alpha === 0) continue;
            
            // Flood fill to get the size of this connected component
            let stack = [[x, y]], pixels = [];
            visited[i] = 1;
            while (stack.length) {
              const [cx, cy] = stack.pop();
              const idx = getIdx(cx, cy);
              pixels.push(idx);
              for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                  if (dx === 0 && dy === 0) continue;
                  const nx = cx + dx, ny = cy + dy;
                  if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;
                  const nidx = getIdx(nx, ny);
                  if (visited[nidx]) continue;
                  if (data[nidx*4+3] === 0) continue;
                  stack.push([nx, ny]);
                  visited[nidx] = 1;
                }
              }
            }
            
            // If this component is large enough, mark it as a main area
            if (pixels.length >= 100) { // Components with 100+ pixels are considered main areas
              for (const idx of pixels) {
                mainAreas.add(idx);
              }
            }
          }
        }
        
        // Second pass: remove small dark specs that are NOT part of main areas
        visited.fill(0); // Reset visited array
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const i = getIdx(x, y);
            if (visited[i]) continue;
            const alpha = data[i*4+3];
            if (alpha === 0) continue;
            if (mainAreas.has(i)) continue; // Skip if this pixel is part of a main area
            
            // Check if this is a dark spec (black/dark colors)
            if (data[i*4] < 50 && data[i*4+1] < 50 && data[i*4+2] < 50) {
              // Flood fill to get the size of this dark spec
              let stack = [[x, y]], pixels = [];
              visited[i] = 1;
              while (stack.length) {
                const [cx, cy] = stack.pop();
                const idx = getIdx(cx, cy);
                pixels.push(idx);
                for (let dx = -1; dx <= 1; dx++) {
                  for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = cx + dx, ny = cy + dy;
                    if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;
                    const nidx = getIdx(nx, ny);
                    if (visited[nidx]) continue;
                    if (data[nidx*4+3] === 0) continue;
                    if (mainAreas.has(nidx)) continue; // Don't include main area pixels
                    if (data[nidx*4] < 50 && data[nidx*4+1] < 50 && data[nidx*4+2] < 50) {
                      stack.push([nx, ny]);
                      visited[nidx] = 1;
                    }
                  }
                }
              }
              
              // Remove small dark specs (less than 100 pixels)
              if (pixels.length < 100) {
                for (const idx of pixels) {
                  data[idx*4+3] = 0; // Make transparent
                }
              }
            }
          }
        }
        this.ctx.putImageData(id, 0, 0);
      }

      download() {
        // Create a download link and trigger it
        const link = document.createElement("a");
        link.download = this.file.name.replace(/\.[^.]+$/, "-cleaned.png");
        
        // Convert canvas to blob and create object URL
        this.canvas.toBlob((blob) => {
          const url = URL.createObjectURL(blob);
          link.href = url;
          
          // Trigger download
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          // Clean up the object URL
          setTimeout(() => URL.revokeObjectURL(url), 100);
        }, "image/png");
      }

      sendToSecondStage() {
        // Create a temporary image from the current canvas
        const img = new Image();
        img.onload = () => {
          // Set the thumbnail preview
          thumbnailPreview.src = img.src;
          
          // Get the visible bounds of the processed image
          const bounds = getVisibleBounds(img);
          
          // Apply spacing and centering
          const spacing = parseFloat(spacingSlider.value) / 100;
          ctx.clearRect(0, 0, 400, 400);
          const scale = 1 - spacing * 2;
          const drawW = bounds.width * scale;
          const drawH = bounds.height * scale;
          const dx = (400 - drawW) / 2;
          const dy = (400 - drawH) / 2;
          
          // Draw the processed image to the main canvas
          ctx.drawImage(img, bounds.x, bounds.y, bounds.width, bounds.height, dx, dy, drawW, drawH);
          
          // Create a blob for download functionality
          canvas.toBlob(blob => {
            processedBlob = blob;
            // Add to processed blobs array for batch download
            if (!processedBlobs.includes(blob)) {
              processedBlobs.push(blob);
            }
          }, "image/png");
          
          // Scroll to the second section
          document.getElementById("canvas").scrollIntoView({ behavior: 'smooth' });
        };
        img.src = this.canvas.toDataURL();
      }
    }

    const editors = [];
    document.getElementById("fileInput").onchange = e => {
      [...e.target.files].forEach(f => editors.push(new ImageEditor(f)));
    };

    downloadSelectedBtn.onclick = () => {
      editors.forEach(ed => ed.selectCheckbox.checked && ed.download());
    };

    selectAllBtn.onclick = () => editors.forEach(ed => ed.selectCheckbox.checked = true);
    deselectAllBtn.onclick = () => editors.forEach(ed => ed.selectCheckbox.checked = false);
  </script>
</body>
</html>