<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Background Remover</title>
  <style>
    body { font-family: sans-serif; padding: 2rem; background: #f9f9f9; text-align: center; }
    .image-container { border: 1px solid #ccc; margin: 1rem auto; display: inline-block; position: relative; }
    canvas { cursor: crosshair; display: block; margin: 0 auto; }
    .controls { margin: 0.5rem 0; }
    label { margin-right: 1rem; }
    button { margin: 0.5rem; }
    .select-checkbox { position: absolute; top: 5px; left: 5px; }
    #bottom-controls { margin-top: 2rem; }
    details { margin: 1rem auto; text-align: left; max-width: 800px; }
  </style>
</head>
<body>
  <h2>Advanced Background Remover</h2>
  <details>
    <summary style="max-width: 640px; margin: 0 auto 1em auto; text-align: center;"><strong>Instructions</strong></summary>
    <p style="max-width: 640px; margin: 0 auto 1em auto;"></p>
      Upload one or more images using the file input below. You can edit each image manually using the brush tools:
      <br><span style="margin-left:2em;"><strong>Erase</strong></span> to remove,
      <br><span style="margin-left:2em;"><strong>Restore</strong></span> to paint back original content, or use
      <br><span style="margin-left:2em;"><strong>Magic Fill</strong></span> to remove areas with similar colors by clicking. Adjust brush size and tolerance as needed.
      <br><br>Optionally, use the:
      <br><span style="margin-left:2em;"><strong>Auto Process</strong></span> button under each image to automatically remove background based on edge detection. 
      <br><br>All actions including auto-processing are undoable using the:
      <br><span style="margin-left:2em;"><strong>Undo</strong></span> button. Select images and click
      <br><span style="margin-left:2em;"><strong>Download Selected</strong></span> to save your edits.
    </p>
    <br>
  </details>

  <input type="file" id="fileInput" accept="image/*" multiple><br>
  <label>Brush Size: <input type="range" id="brushSize" min="5" max="100" value="30"></label>
  <label><input type="radio" name="mode" value="erase" checked> Erase</label>
  <label><input type="radio" name="mode" value="restore"> Restore</label>
  <label><input type="radio" name="mode" value="bucket"> Magic Fill</label>
  <label>Tolerance: <input type="range" id="tolerance" min="0" max="100" value="30"></label>

  <div id="imagesArea"></div>

  <div id="bottom-controls">
    <button id="selectAllBtn">Select All</button>
    <button id="deselectAllBtn">Deselect All</button>
    <button id="downloadSelectedBtn">Download Selected</button>
  </div>

  <script>
    const brushSizeInput = document.getElementById("brushSize");
    const toleranceInput = document.getElementById("tolerance");
    const modeRadios = document.querySelectorAll('input[name="mode"]');
    const imagesArea = document.getElementById("imagesArea");
    const downloadSelectedBtn = document.getElementById("downloadSelectedBtn");
    const selectAllBtn = document.getElementById("selectAllBtn");
    const deselectAllBtn = document.getElementById("deselectAllBtn");

    let brushSize = parseInt(brushSizeInput.value);
    let tolerance = parseInt(toleranceInput.value);
    let mode = "erase";

    brushSizeInput.oninput = e => brushSize = parseInt(e.target.value);
    toleranceInput.oninput = e => tolerance = parseInt(e.target.value);
    modeRadios.forEach(r => r.onchange = () => mode = document.querySelector('input[name="mode"]:checked').value);

    function colorDistance(c1, c2) {
      return Math.sqrt((c1[0]-c2[0])**2 + (c1[1]-c2[1])**2 + (c1[2]-c2[2])**2);
    }

    function getPixel(data, x, y, w) {
      const i = (y * w + x) * 4;
      return [data[i], data[i+1], data[i+2], data[i+3]];
    }

    function setAlpha(data, x, y, w, alpha) {
      const i = (y * w + x) * 4;
      data[i+3] = alpha;
    }

    function floodFill(x, y, data, w, h, base, tol) {
      const stack = [[x, y]];
      const visited = new Set();
      while (stack.length) {
        const [cx, cy] = stack.pop();
        const key = `${cx},${cy}`;
        if (visited.has(key)) continue;
        visited.add(key);
        const px = getPixel(data, cx, cy, w);
        if (px[3] === 0 || colorDistance(px, base) > tol) continue;
        setAlpha(data, cx, cy, w, 0);
        if (cx > 0) stack.push([cx-1, cy]);
        if (cx < w-1) stack.push([cx+1, cy]);
        if (cy > 0) stack.push([cx, cy-1]);
        if (cy < h-1) stack.push([cx, cy+1]);
      }
    }

    function getEdgeColor(data, w, h) {
      const sample = [];
      for (let x = 0; x < w; x++) sample.push([x,0],[x,h-1]);
      for (let y = 0; y < h; y++) sample.push([0,y],[w-1,y]);
      return sample.reduce((acc, [x,y]) => {
        const i = (y*w + x)*4;
        acc[0] += data[i]; acc[1] += data[i+1]; acc[2] += data[i+2];
        return acc;
      }, [0,0,0]).map(v => v/sample.length);
    }

    class ImageEditor {
      constructor(file) {
        this.file = file;
        this.canvas = document.createElement("canvas");
        this.ctx = this.canvas.getContext("2d");
        this.container = document.createElement("div");
        this.container.className = "image-container";

        this.selectCheckbox = document.createElement("input");
        this.selectCheckbox.type = "checkbox";
        this.selectCheckbox.className = "select-checkbox";
        this.selectCheckbox.checked = true;

        this.undoBtn = document.createElement("button");
        this.undoBtn.textContent = "Undo";

        this.autoBtn = document.createElement("button");
        this.autoBtn.textContent = "Auto Process";

        this.downloadBtn = document.createElement("button");
        this.downloadBtn.textContent = "Download";

        this.controls = document.createElement("div");
        this.controls.className = "controls";
        this.controls.appendChild(this.undoBtn);
        this.controls.appendChild(this.autoBtn);
        this.controls.appendChild(this.downloadBtn);

        this.container.appendChild(this.selectCheckbox);
        this.container.appendChild(this.canvas);
        this.container.appendChild(this.controls);
        imagesArea.appendChild(this.container);

        this.img = new Image();
        this.img.onload = () => this.init();
        this.img.src = URL.createObjectURL(file);

        this.undoStack = [];

        this.canvas.addEventListener("mousedown", e => { this.drawing = true; this.draw(e); });
        this.canvas.addEventListener("mousemove", e => this.drawing && this.draw(e));
        this.canvas.addEventListener("mouseup", () => this.drawing = false);
        this.canvas.addEventListener("mouseleave", () => this.drawing = false);

        this.undoBtn.onclick = () => this.undo();
        this.autoBtn.onclick = () => this.autoProcess();
        this.downloadBtn.onclick = () => this.download();
      }

      init() {
        this.canvas.width = this.img.width;
        this.canvas.height = this.img.height;
        this.ctx.drawImage(this.img, 0, 0);
        this.original = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      }

      autoProcess() {
        this.save();
        let id = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        let d = id.data, w = this.canvas.width, h = this.canvas.height;
        let bg = getEdgeColor(d, w, h);
        for (let i = 0; i < d.length; i += 4) {
          let [r,g,b] = [d[i], d[i+1], d[i+2]];
          let dist = colorDistance([r,g,b], bg);
          if (dist < 50) d[i+3] = 0;
        }
        this.ctx.putImageData(id, 0, 0);
      }

      draw(e) {
        const r = this.canvas.getBoundingClientRect();
        const x = Math.floor(e.clientX - r.left);
        const y = Math.floor(e.clientY - r.top);
        if (mode === "erase" || mode === "restore") this.save();
        if (mode === "erase") {
          this.ctx.save();
          this.ctx.beginPath();
          this.ctx.arc(x, y, brushSize/2, 0, 2*Math.PI);
          this.ctx.clip();
          this.ctx.clearRect(x-brushSize/2, y-brushSize/2, brushSize, brushSize);
          this.ctx.restore();
        } else if (mode === "restore") {
          for (let dx = -brushSize/2; dx < brushSize/2; dx++) {
            for (let dy = -brushSize/2; dy < brushSize/2; dy++) {
              const sx = x + dx, sy = y + dy;
              if (sx < 0 || sy < 0 || sx >= this.canvas.width || sy >= this.canvas.height) continue;
              const idx = (sy * this.canvas.width + sx) * 4;
              const r = this.original.data[idx];
              const g = this.original.data[idx + 1];
              const b = this.original.data[idx + 2];
              const a = this.original.data[idx + 3];
              this.ctx.fillStyle = `rgba(${r},${g},${b},${a/255})`;
              this.ctx.fillRect(sx, sy, 1, 1);
            }
          }
        } else if (mode === "bucket") {
          this.save();
          let id = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
          let px = getPixel(id.data, x, y, this.canvas.width);
          floodFill(x, y, id.data, this.canvas.width, this.canvas.height, px, tolerance);
          this.ctx.putImageData(id, 0, 0);
        }
      }

      save() {
        this.undoStack.push(this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height));
        if (this.undoStack.length > 10) this.undoStack.shift();
      }

      undo() {
        if (!this.undoStack.length) return;
        this.ctx.putImageData(this.undoStack.pop(), 0, 0);
      }

      download() {
        const a = document.createElement("a");
        a.download = this.file.name.replace(/\.[^.]+$/, "-cleaned.png");
        a.href = this.canvas.toDataURL();
        a.click();
      }
    }

    const editors = [];
    document.getElementById("fileInput").onchange = e => {
      [...e.target.files].forEach(f => editors.push(new ImageEditor(f)));
    };

    downloadSelectedBtn.onclick = () => {
      editors.forEach(ed => ed.selectCheckbox.checked && ed.download());
    };

    selectAllBtn.onclick = () => editors.forEach(ed => ed.selectCheckbox.checked = true);
    deselectAllBtn.onclick = () => editors.forEach(ed => ed.selectCheckbox.checked = false);
  </script>
</body>
</html>